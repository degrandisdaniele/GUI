import React, { useRef, useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Upload, Maximize2, RotateCcw } from "lucide-react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import * as THREE from 'three';

export default function ModelViewer({ prosthesis, onColorsDetected }) {
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);
  const modelRef = useRef(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [detectedColors, setDetectedColors] = useState([]);
  const [isUploading, setIsUploading] = useState(false);

  useEffect(() => {
    if (mountRef.current && !rendererRef.current) {
      initializeViewer();
    }

    return () => {
      if (rendererRef.current) {
        rendererRef.current.dispose();
      }
    };
  }, []);

  useEffect(() => {
    if (prosthesis.model_file_url && sceneRef.current) {
      loadModel(prosthesis.model_file_url);
    }
  }, [prosthesis.model_file_url]);

  const initializeViewer = () => {
    const width = mountRef.current.clientWidth;
    const height = 400;

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);
    sceneRef.current = scene;

    // Camera
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.set(0, 0, 5);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    rendererRef.current = renderer;
    mountRef.current.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Controls simulation with mouse
    let isRotating = false;
    let previousMousePosition = { x: 0, y: 0 };

    const handleMouseDown = (event) => {
      isRotating = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    };

    const handleMouseMove = (event) => {
      if (!isRotating || !modelRef.current) return;

      const deltaMove = {
        x: event.clientX - previousMousePosition.x,
        y: event.clientY - previousMousePosition.y
      };

      modelRef.current.rotation.y += deltaMove.x * 0.01;
      modelRef.current.rotation.x += deltaMove.y * 0.01;

      previousMousePosition = { x: event.clientX, y: event.clientY };
    };

    const handleMouseUp = () => {
      isRotating = false;
    };

    const handleWheel = (event) => {
      if (!modelRef.current) return;
      
      const scale = modelRef.current.scale.x - event.deltaY * 0.001;
      const clampedScale = Math.max(0.1, Math.min(3, scale));
      modelRef.current.scale.setScalar(clampedScale);
    };

    renderer.domElement.addEventListener('mousedown', handleMouseDown);
    renderer.domElement.addEventListener('mousemove', handleMouseMove);
    renderer.domElement.addEventListener('mouseup', handleMouseUp);
    renderer.domElement.addEventListener('wheel', handleWheel);

    // Animation loop
    const animate = () => {
      requestAnimationFrame(animate);
      if (!isRotating && modelRef.current) {
        modelRef.current.rotation.y += 0.005;
      }
      renderer.render(scene, camera);
    };
    animate();
  };

  const loadModel = async (modelUrl) => {
    try {
      // For demo purposes, create a simple colored cube instead of loading GLB
      // In a real implementation, you would use GLTFLoader
      
      if (modelRef.current) {
        sceneRef.current.remove(modelRef.current);
      }

      // Create a demo model with multiple colors
      const geometry = new THREE.BoxGeometry(2, 2, 2);
      const materials = [
        new THREE.MeshLambertMaterial({ color: 0xff6b6b }), // Red
        new THREE.MeshLambertMaterial({ color: 0x4ecdc4 }), // Teal
        new THREE.MeshLambertMaterial({ color: 0x45b7d1 }), // Blue
        new THREE.MeshLambertMaterial({ color: 0x96ceb4 }), // Green
        new THREE.MeshLambertMaterial({ color: 0xfeca57 }), // Yellow
        new THREE.MeshLambertMaterial({ color: 0xff9ff3 })  // Pink
      ];

      const model = new THREE.Mesh(geometry, materials);
      model.castShadow = true;
      model.receiveShadow = true;
      modelRef.current = model;
      sceneRef.current.add(model);

      // Simulate color detection
      const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
      setDetectedColors(colors);
      onColorsDetected(colors);

    } catch (error) {
      console.error('Error loading model:', error);
    }
  };

  const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.name.toLowerCase().endsWith('.glb')) {
      alert('Please upload a .glb file');
      return;
    }

    setIsUploading(true);
    try {
      // Simulate file upload - in real implementation, use UploadFile integration
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // For demo, just trigger the demo model load
      loadModel('demo_model_url');
    } catch (error) {
      console.error('Upload error:', error);
    } finally {
      setIsUploading(false);
    }
  };

  const resetView = () => {
    if (modelRef.current) {
      modelRef.current.rotation.set(0, 0, 0);
      modelRef.current.scale.setScalar(1);
    }
  };

  return (
    <>
      <Card className="glass-morphism professional-shadow">
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center gap-2 text-slate-900">
              <Upload className="w-5 h-5 text-blue-600" />
              3D Model Viewer
            </CardTitle>
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="icon"
                onClick={resetView}
                className="rounded-lg"
              >
                <RotateCcw className="w-4 h-4" />
              </Button>
              <Button
                variant="outline"
                size="icon"
                onClick={() => setIsModalOpen(true)}
                className="rounded-lg"
              >
                <Maximize2 className="w-4 h-4" />
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {!prosthesis.model_file_url && (
            <div className="mb-4">
              <label className="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100 transition-colors">
                <div className="flex flex-col items-center justify-center pt-5 pb-6">
                  <Upload className="w-8 h-8 mb-4 text-gray-500" />
                  <p className="mb-2 text-sm text-gray-500">
                    <span className="font-semibold">Click to upload</span> 3D model
                  </p>
                  <p className="text-xs text-gray-500">.GLB files only</p>
                </div>
                <input
                  type="file"
                  className="hidden"
                  accept=".glb"
                  onChange={handleFileUpload}
                  disabled={isUploading}
                />
              </label>
            </div>
          )}

          <div 
            ref={mountRef} 
            className="w-full h-96 bg-slate-100 rounded-lg border-2 border-slate-200 relative overflow-hidden"
          >
            {!prosthesis.model_file_url && (
              <div className="absolute inset-0 flex items-center justify-center">
                <p className="text-slate-500">Upload a 3D model to begin</p>
              </div>
            )}
          </div>

          <div className="mt-4 text-sm text-slate-600">
            <p>• <strong>Rotate:</strong> Click and drag</p>
            <p>• <strong>Zoom:</strong> Mouse wheel</p>
            <p>• <strong>Colors detected:</strong> {detectedColors.length}</p>
          </div>
        </CardContent>
      </Card>

      {/* Modal for enlarged view */}
      <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
        <DialogContent className="max-w-4xl h-[80vh]">
          <DialogHeader>
            <DialogTitle>3D Model - Enlarged View</DialogTitle>
          </DialogHeader>
          <div className="flex-1 bg-slate-100 rounded-lg">
            <div className="w-full h-full min-h-[500px] bg-slate-100 rounded-lg border">
              {/* In a real implementation, you'd create another Three.js instance here */}
              <div className="flex items-center justify-center h-full">
                <p className="text-slate-500">Enlarged 3D viewer would be rendered here</p>
              </div>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}