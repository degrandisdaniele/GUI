import React, { useState, useEffect } from "react";
import { Prosthesis } from "@/entities/Prosthesis";
import { useNavigate } from "react-router-dom";
import { createPageUrl } from "@/utils";
import { motion } from "framer-motion";
import { ArrowLeft, Save, CheckCircle, Download, AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import ModelViewer from "../components/manufacturing/ModelViewer";
import ColorProperties from "../components/manufacturing/ColorProperties";
import ProcessChain from "../components/manufacturing/ProcessChain";
import NotificationSystem from "../components/manufacturing/NotificationSystem";

export default function Manufacturing() {
  const navigate = useNavigate();
  const [prosthesis, setProsthesis] = useState(null);
  const [processChain, setProcessChain] = useState([]);
  const [colorProperties, setColorProperties] = useState({});
  const [notifications, setNotifications] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isValidating, setIsValidating] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [expandedProcess, setExpandedProcess] = useState(null);

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const prosthesisId = urlParams.get('prosthesis');
    if (prosthesisId) {
      loadProsthesis(prosthesisId);
    } else {
      navigate(createPageUrl("Dashboard"));
    }
  }, [navigate]);

  const loadProsthesis = async (prosthesisId) => {
    try {
      const prostheses = await Prosthesis.list();
      const selectedProsthesis = prostheses.find(p => p.id === prosthesisId);
      if (selectedProsthesis) {
        setProsthesis(selectedProsthesis);
        
        // Parse stored data
        const defaultChain = selectedProsthesis.default_process_chain 
          ? JSON.parse(selectedProsthesis.default_process_chain) 
          : [];
        setProcessChain(defaultChain);

        const savedColorProps = selectedProsthesis.color_properties
          ? JSON.parse(selectedProsthesis.color_properties)
          : {};
        setColorProperties(savedColorProps);

        // Load from localStorage if available
        const localStorageKey = `prosthesis_${prosthesisId}_processes`;
        const localData = localStorage.getItem(localStorageKey);
        if (localData) {
          setProcessChain(JSON.parse(localData));
        }
      }
    } catch (error) {
      console.error("Error loading prosthesis:", error);
      addNotification("Error loading prosthesis data", "error");
    } finally {
      setIsLoading(false);
    }
  };

  const addNotification = (message, type = "info") => {
    const id = Date.now();
    setNotifications(prev => [...prev, { id, message, type }]);
    setTimeout(() => {
      setNotifications(prev => prev.filter(n => n.id !== id));
    }, 5000);
  };

  const handleSaveProperties = async () => {
    try {
      // Get unique properties from color mapping
      const uniqueProperties = [...new Set(Object.values(colorProperties))].filter(Boolean);
      
      if (uniqueProperties.length === 0) {
        addNotification("Please assign at least one property to proceed", "warning");
        return;
      }

      addNotification("Generating optimized process chain...", "info");

      // Simulate API call to scheduler
      const schedulerResponse = await simulateSchedulerAPI(prosthesis.id, uniqueProperties);
      
      if (schedulerResponse.success) {
        setProcessChain(schedulerResponse.processChain);
        
        // Save to localStorage
        const localStorageKey = `prosthesis_${prosthesis.id}_processes`;
        localStorage.setItem(localStorageKey, JSON.stringify(schedulerResponse.processChain));
        
        // Update prosthesis with color properties
        await Prosthesis.update(prosthesis.id, {
          color_properties: JSON.stringify(colorProperties)
        });

        addNotification("New optimized process chain generated successfully!", "success");
      } else {
        addNotification("Failed to generate process chain", "error");
      }
    } catch (error) {
      addNotification("Error generating process chain", "error");
    }
  };

  const handleValidateProcess = async () => {
    if (expandedProcess === null) {
      addNotification("Please expand a process to validate", "warning");
      return;
    }

    setIsValidating(true);
    try {
      const processToValidate = processChain[expandedProcess];
      
      // Clean and prepare data for validation
      const cleanedParameters = cleanParametersForValidation(processToValidate.parameters);
      
      // Simulate API call to validation endpoint
      const validationResponse = await simulateValidationAPI(cleanedParameters);
      
      if (validationResponse.valid) {
        addNotification("Process parameters are valid ✓", "success");
      } else {
        const violations = validationResponse.violations.join(", ");
        addNotification(`Invalid parameters: ${violations}`, "error");
      }
    } catch (error) {
      addNotification("Error during validation", "error");
    } finally {
      setIsValidating(false);
    }
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    addNotification("Generating RCP files...", "info");
    
    try {
      // Gather all current parameter values
      const allProcessData = processChain.map(process => ({
        name: process.name,
        parameters: process.parameters
      }));

      // Simulate API call to generate files
      const response = await simulateFileGenerationAPI(allProcessData);
      
      if (response.success) {
        // Simulate file download
        const blob = new Blob([response.fileContent], { type: 'application/zip' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${prosthesis.name}_processes_${new Date().toISOString().split('T')[0]}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        addNotification("RCP files downloaded successfully!", "success");
      } else {
        addNotification("Failed to generate files", "error");
      }
    } catch (error) {
      addNotification("Error generating files", "error");
    } finally {
      setIsSubmitting(false);
    }
  };

  const updateProcessParameters = (processIndex, parameters) => {
    const updatedChain = [...processChain];
    updatedChain[processIndex].parameters = parameters;
    setProcessChain(updatedChain);
    
    // Save to localStorage
    const localStorageKey = `prosthesis_${prosthesis.id}_processes`;
    localStorage.setItem(localStorageKey, JSON.stringify(updatedChain));
  };

  // Utility functions
  const simulateSchedulerAPI = async (prosthesisId, properties) => {
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Return a mock optimized process chain
    return {
      success: true,
      processChain: [
        {
          id: "process_1",
          name: "Surface Preparation",
          parameters: {
            temperature: { value: 180, unit: "°C", type: "number" },
            duration: { value: 45, unit: "min", type: "number" },
            pressure: { value: 2.5, unit: "bar", type: "number" }
          },
          recipes: ["Standard", "High-temp", "Low-pressure"]
        },
        {
          id: "process_2", 
          name: "Property Application",
          parameters: {
            coating_type: { value: "Antibacterial", type: "select", options: ["Antibacterial", "Osseointegration", "No tissue adhesion"] },
            thickness: { value: 50, unit: "μm", type: "number" },
            curing_time: { value: 120, unit: "min", type: "number" }
          },
          recipes: ["Thin coating", "Standard coating", "Thick coating"]
        }
      ]
    };
  };

  const simulateValidationAPI = async (parameters) => {
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Simple validation logic
    const violations = [];
    Object.entries(parameters).forEach(([key, value]) => {
      if (typeof value === 'number' && (value < 0 || value > 1000)) {
        violations.push(`${key} out of range`);
      }
    });
    
    return {
      valid: violations.length === 0,
      violations
    };
  };

  const simulateFileGenerationAPI = async (processData) => {
    await new Promise(resolve => setTimeout(resolve, 2500));
    
    const mockZipContent = JSON.stringify({
      processes: processData,
      generated_at: new Date().toISOString(),
      prosthesis_id: prosthesis.id
    }, null, 2);
    
    return {
      success: true,
      fileContent: mockZipContent
    };
  };

  const cleanParametersForValidation = (parameters) => {
    const cleaned = {};
    Object.entries(parameters).forEach(([key, param]) => {
      if (param.type === 'number') {
        // Convert comma decimal separator to dot
        const numValue = typeof param.value === 'string' 
          ? parseFloat(param.value.replace(',', '.'))
          : param.value;
        cleaned[key] = numValue;
      } else if (param.type === 'boolean') {
        cleaned[key] = param.value === 'true' || param.value === true;
      } else if (key !== 'inducesProperty') {
        cleaned[key] = param.value;
      }
    });
    return cleaned;
  };

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-slate-600">Loading prosthesis data...</p>
        </div>
      </div>
    );
  }

  if (!prosthesis) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <AlertCircle className="w-16 h-16 text-slate-400 mx-auto mb-4" />
          <h2 className="text-2xl font-bold text-slate-900 mb-2">Prosthesis Not Found</h2>
          <Button onClick={() => navigate(createPageUrl("Dashboard"))}>
            Back to Dashboard
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-slate-50">
      <NotificationSystem notifications={notifications} />
      
      {/* Header */}
      <div className="glass-morphism border-b border-slate-200 px-6 py-4">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Button
              variant="outline"
              size="icon"
              onClick={() => navigate(createPageUrl("Dashboard"))}
              className="rounded-lg"
            >
              <ArrowLeft className="w-4 h-4" />
            </Button>
            <div>
              <h1 className="text-2xl font-bold text-slate-900">{prosthesis.name}</h1>
              <p className="text-slate-600">Model ID: {prosthesis.model_id}</p>
            </div>
          </div>
          <div className="flex gap-3">
            <Button
              onClick={handleValidateProcess}
              disabled={isValidating || expandedProcess === null}
              className="bg-blue-600 hover:bg-blue-700 px-6"
            >
              {isValidating ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
                  Validating...
                </>
              ) : (
                <>
                  <CheckCircle className="w-4 h-4 mr-2" />
                  Validate
                </>
              )}
            </Button>
            <Button
              onClick={handleSubmit}
              disabled={isSubmitting}
              className="bg-green-600 hover:bg-green-700 px-6"
            >
              {isSubmitting ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
                  Generating...
                </>
              ) : (
                <>
                  <Download className="w-4 h-4 mr-2" />
                  Submit
                </>
              )}
            </Button>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="max-w-7xl mx-auto p-6">
        <div className="grid lg:grid-cols-2 gap-6 h-full">
          {/* Left Panel - 3D Model & Properties */}
          <div className="space-y-6">
            <ModelViewer 
              prosthesis={prosthesis}
              onColorsDetected={(colors) => {
                // Initialize color properties if not already set
                const newColorProps = { ...colorProperties };
                colors.forEach(color => {
                  if (!newColorProps[color]) {
                    newColorProps[color] = "";
                  }
                });
                setColorProperties(newColorProps);
              }}
            />
            
            <ColorProperties
              colorProperties={colorProperties}
              availableProperties={prosthesis.available_properties ? JSON.parse(prosthesis.available_properties) : []}
              onPropertiesChange={setColorProperties}
              onSave={handleSaveProperties}
            />
          </div>

          {/* Right Panel - Process Chain */}
          <div>
            <ProcessChain
              processes={processChain}
              expandedProcess={expandedProcess}
              onExpandProcess={setExpandedProcess}
              onUpdateParameters={updateProcessParameters}
            />
          </div>
        </div>
      </div>
    </div>
  );
}